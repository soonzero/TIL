# 인증 방식 (OAuth 2.0, JWT, API Key)

## OAuth 2.0(Open Authentification 2.0)

인터넷 사용자들이 비밀번호를 별도로 제공하지 않고, 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 앱의 접근 권한을 부여할 수 있는 개방형 표준 방법을 말한다.

구글, 페이스북, 트위터 등이 사용하고 있으며 타사 앱 및 웹 사이트의 계정에 대한 정보를 공유할 수 있도록 허용하고 있다.

- OAuth 1.0

  - 웹 앱이 아닌 앱에서는 사용하기 곤란하다는 단점이 있다.

  - 절차가 복잡해서 OAuth 구현 라이브러리를 제작하기 어렵고, Service Provider에게도 연산 부담이 발생한다.

  - 이를 개선하기 위해 등장한 것이 OAuth 2.0이다.

- OAuth 2.0

  - 웹 앱, 데스크톱 앱, 휴대폰 등 장치에 대한 특정 권한 부여 흐름을 제공하면서 클라이언트 개발 단순성에 중점을 뒀다.

  - 클라이언트 앱에 암호화가 필요 없고, 서명을 단순화했다.

  - Access Token의 수명을 지정할 수 있도록 했고, Refresh Token이라는 개념이 등장했다.

  - 사용되는 용어 체계가 OAuth 1.0과 완전히 다르며, 같은 목적이라도 다른 프로토콜이라고 이해하는 것이 좋다.

### 사용되는 용어

- 사용자: 계정을 가지고 있는 개인

- 소비자: OAuth를 사용해 서비스 제공자에게 접근하는 웹 사이트 or 앱

- 서비스 제공자: OAuth를 통해 접근을 지원하는 웹 앱 (ex. 구글, 페이스북, 트위터 등)

- 소비자 비밀번호: 서비스 제공자에서 소비자가 자신임을 인증하기 위한 키

- 요청 토큰(Refresh Token): 소비자가 사용자에게 접근 권한을 인증받기 위해 필요한 정보가 담겨있는 키

- 접근 토큰(Access Token): 인증 후에 사용자가 서비스 제공자가 아닌 소비자를 통해 보호 자원에 접근하기 위한 키 값

### 인증 과정

(ex. **내**가 **A**라는 사이트에 **카카오** 계정으로 로그인)

    소비자 <-> 서비스 제공자

1. 소비자가 서비스 제공자에게 요청 토큰을 요청한다.

   - "A" 사이트에서 "카카오"에 요청

2. 서비스 제공자가 소비자에게 요청 토큰을 발급해준다.

   - "카카오"에서 "A" 사이트에 요청 토큰 발급

3. 소비자가 사용자를 서비스 제공자로 이동시키면서, 사용자로 하여금 소비자 비밀번호로 인증을 수행하도록 한다.

   - "A" 사이트에서 "나"를 "카카오"로 이동시킨다.

   - "나"는 "카카오"에 로그인함으로써 사용자 인증을 수행

4. 서비스 제공자가 사용자를 소비자로 이동시킨다.

   - "카카오"에서 사용자 인증을 끝낸 "나"를 "A" 사이트로 다시 이동시킨다.

5. 소비자가 접근 토큰을 요청한다.

   - "A" 사이트에서 "카카오"에 접근 토큰을 요청

6. 서비스 제공자가 접근 토큰을 발급한다.

   - "카카오"에서 "A" 사이트에 접근 토큰을 발행

7. 발급된 접근 토큰을 이용해서 소비자에서 사용자 정보에 접근한다.

   - "A" 사이트가 "카카오"에게서 발급 받은 접근 토큰으로 "내" 정보에 접근

## JWT(JSON Web Token)

JWT는 웹 표준(RFC 7519)로써 두 개체에서 JSON 객체를 사용하여 가볍고 자가수용적인 방식으로 정보를 안전성 있게 전달해준다.

<br />

### 구성 요소

JWT는 `.`을 구분자로 하여 3가지의 문자열로 구성된다.

<img src="https://postfiles.pstatic.net/MjAyMjA1MjJfMjkx/MDAxNjUzMTg3NTE2MDA4.7pJhS682wScZ76PELAV39EewqvjoAvT9zc-XjTdQ4Vsg.o3Yvj1HSyA-Bh4c_3WX61pVjytkLoPy66oCvJaaqlCEg.PNG.hty018/image.png?type=w773" alt="jwt" />

<br />

#### 헤더(header)

- 헤더는 `typ`와 `alg` 두 가지의 정보를 지니고 있다.

- `typ`는 토큰의 타입을 지정한다.

- `alg`는 해싱 알고리즘을 지정한다. 기본적으로 `HMAC, `SHA256`, 또는 `RSA`가 사용된다.

<br />

#### 내용(payload)

- 토큰에 담을 `claim(클레임)` 정보를 포함하고 있다.

- payload에 담는 정보의 한 조각을 클레임이라고 부르고, `key-value`의 한 쌍으로 구성된다.

- 하나의 토큰에 여러 개의 클레임을 넣을 수 있지만, 너무 많아질 경우 토큰의 길이가 길어질 수 있다.

- 클레임의 종류

  - 등록된(registered) 클레임: 서비스에서 필요한 정보들이 아닌, 토큰에 대한 정보를 담기 위해 이름이 이미 정해진 클레임이다. 등록된 클레임의 사용은 모두 선택적이며, 이에 포함된 크레임 이름들은 다음과 같다.

    - `iss`: 토큰 발급자(issuer)

    - `sub`: 토큰 제목(subject)

    - `aud`: 토큰 대상자(audience)

    - `exp`: 토큰의 만료 시간(expiration), 시간은 NumericDate 형식으로 되어 있어야 하며, 언제나 현재 시간보다 이후로 설정되어 있어야 한다.

    - `nbf`: Not before를 의미하며, 토큰의 활성 날짜와 비슷한 개념이다. 이것도 NumericDate형식으로 날짜를 지정하며, 이 날짜가 지나기 전까지는 토큰이 처리되지 않는다.

    - `iat`: 토큰이 발급된 시간(issued at)으로, 이 값을 사용하여 토큰의 age가 얼마나 되었는지 판단할 수 있다.

    - `jti`: JWT의 고유 식별자로, 주로 중복적인 처리를 방지하기 위해 사용되며, 일회용 토큰에 사용 시 유용하다.

  - 공개(public) 클레임: 충돌이 방지된 이름을 가지고 있어야 한다. 충돌을 방지하기 위해서는, 클레임 이름을 URI 형식으로 짓는다.

    ```
    {
      "https://example.com/jwt_claims/is_admin": true
    }
    ```

  - 비공개(private) 클레임: 양측(보통 클라이언트 <->서버) 합의 하에 사용되는 클레임 이름들이다. 공개 클레임과는 달리 이름이 중복되어 충돌이 발생할 수 있으니 사용 시 유의해야 한다.

<br />

### 서명(signature)

- 서명은 헤더의 인코딩 값과 정보의 인코딩 값을 합친 후 주어진 비밀키로 해쉬를 하여 생성한다. 이렇게 만든 해쉬를 `base64` 형태로 나타내게 된다.

<br />

### 로그인 인증 시 JWT 사용

- 유효기간이 짧은 토큰을 발급하게 되면 사용자는 자주 로그인을 해야 하므로 번거롭다.

- 반대로 유효기간이 긴 토큰을 발급하게 되면 제3자에게 토큰을 탈취당할 경우 보안에 취약하다는 단점이 있다.

- 이 점을 보완하기 위해 Refresh Token을 사용한다.

  - Refresh Token은 Access Token과 똑같은 JWT이지만, Access Token의 유효기간이 만료되었을 때 새로 발급받을 수 있는 열쇠가 된다.

  - 예를 들어, Refresh Token의 유효기간이 1일, Access Token의 유효기간이 1시간이라고 하자.

  - 사용자는 Access Token으로 1시간 동안 API 요청을 하다가 시간이 만료되면, Refresh Token으로 API 요청에 필요한 새로운 Access Token을 발급받는다.

  - 이 방법 또한 Access Token이 탈취당한다고 해도 정보가 유출이 되는 걸 완벽하게 막을 수는 없지만, 더 짧은 유효기간 때문에 탈취되는 가능성이 적다는 점을 이용한 것이다.

  - Refresh Token 또한 유효기간이 만료됐다면, 사용자는 새로 로그인해야 한다. Refresh Token도 탈취될 가능성이 있기 때문에 적절한 유효기간 설정이 필요하다.

- 로그인 인증 절차

    <img src="https://camo.githubusercontent.com/0fcc5fdd7d589d975360d4efca148bc26587b912/68747470733a2f2f7374617469632e7061636b742d63646e2e636f6d2f70726f64756374732f393738313738343339353430372f67726170686963732f4230333635335f30385f30322e6a7067" alt="authentication-with-jwt">

## API Key

- 서비스들이 거대해지면서 기능들을 분리하기 시작했는데, 이를 위해 모듈이나 앱 간의 공유와 독립성을 보장하기 위한 기능들이 등장했다.

- 그 중 가장 먼저 등장하고 보편적으로 쓰이는 기술이 API Key다.

### 동작 방식

1. 사용자는 API Key를 발급받는다.

   - 발급 과정은 서비스에 따라 다른데, 공공기관의 API 같은 경우에는 신청에 필요한 양식을 제출하면 관리자가 확인 후 Key를 발급해 주는 형태이다.

2. 해당 API를 사용하기 위해 Key와 함께 요청을 보낸다.

3. 앱은 요청이 오면 Key를 통해 사용자의 정보를 확인하고, 권한을 확인한다.

4. 해당 Key의 인증과 인가에 따라 데이터를 사용자에게 반환한다.

### 문제점

API Key를 사용자에게 직접 발급하고, 해당 Key를 통해 통신하기 때문에 통신 구간이 암호화가 잘 되어 있더라도 Key가 유출된 경우에는 대비하기 힘들다.

그렇기 때문에 주기적으로 Key를 업데이트 해야 하고, 이는 곧 번거롭고 예기치 못한 상황의 발생으로 이어질 수 있다.

또한 Key 한 가지로 정보를 제어하기 때문에 보안 문제가 발생하기도 쉽다.
