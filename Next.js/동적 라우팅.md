# Next.js

## 동적 라우팅 (Dynamic Routes)

- Next.js는 dynamic URLs을 이용해서 외부 데이터에 의존하는 **path**를 가진 페이지를 정적으로 생성한다

    <img src="https://velog.velcdn.com/images%2Fjaewoneee%2Fpost%2F07cde0a6-77a4-4559-a86a-e62e52b7e5e9%2FGroup%205.png" alt="page path depends on external data" />

    <br />

    <img src="https://velog.velcdn.com/images%2Fjaewoneee%2Fpost%2Fcf03ff29-771e-4b24-a591-c9ead8c18859%2FGroup%204.png" alt="dynamic routes" />

<br />

- `getStaticPaths`, `getStaticProps`, Rendering Markdown

  - 리턴되는 배열은 단순 문자열의 배열이 아니라, 객체의 배열을 리턴해야 한다. 각각의 객체는 `params`라는 키를 가지고 있고, `id`라는 키를 가진 객체를 가져야 한다. (`[id]`)를 파일 이름으로 사용하기 때문이다). 그렇지 않으면 `getStaticPaths`는 작동하지 않는다.

  - 그리고 마크다운을 렌더링하기 위해서 `remark`라는 라이브러리를 사용해야 한다.

        npm install remark remark-html

  - lib / posts.js

    ```
    import { remark } from "remark";
    import html from "remark-html";

    ...

    export function getAllPostIds() {
      const fileNames = fs.readdirSync(postsDirectory)

      return fileNames.map(fileName => {
        return {
          params: {
            id: fileName.replace(/\.md$/, "")
          }
        }
      })
    }

    export async function getPostData(id) {
      const fullPath = path.join(postsDirectory, `${id}.md`})
      const fileContents = fs.readFileSync(fullPath, "utf8")

      const matterResult = matter(fileContents)
      const processedContent = await remark()
        .use(html)
        .process(matterResult.content);

      const contentHtml = processedContent.toString();

      return {
        id,
        contentHtml,
        ...matterResult.data
      }
    }
    ```

  - pages / posts / [id].js

        ```
        import Layout from "../../components/layout"
        import { getAllPostIds, getPostData } from "../../lib/posts"

        export async function getStaticProps({ params }) {
          const postData = getPostData(params.id)
          return {
            props: {
              postData
            }
          }
        }

        export async function getStaticPaths() {
          const paths = getAllPostIds()
          return {
            paths,
            fallback: false
          }
        }

        export default function Post() {
          return (
            <Layout>
              {postData.title}
              <br />
              {postData.id}
              <br />
              {postData.date}
              <br />
              <div dangerouslySetInnerHTML={{ __html: postData.contentHtml }} />
            </Layout>
          )
        }
        ```

  - [dangerouslySetInnerHTML](https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml "dangerouslySetInnerHTML")

    - React에서 DOM(html)을 변경하기 위해 innerHTML을 설정하는 것은 지양해야 한다.

    - XSS(Cross-Site-Scripting) 공격에 취약해지기 때문이다.

    - 그래도 innerHTML을 사용해야 한다면 이 속성을 사용하는 것이 안전하지 않다는 것을 다음과 같이 명시적으로 표현해줘야 한다고 한다.

          <div dangerouslySetInnerHTML = {{ __html: html }} />

<hr />

### 추가 내용

- Fetching data from External API or Query Database

  - `getStaticProps`와 마찬가지로 `getStaticPaths`도 어떤 데이터 소스에서든 데이터를 가져올 수 있다.

  - 위 예제에서는 내부 파일 시스템에서 데이터를 가져왔는데, 다음과 같이 외부 api로부터 데이터를 가져올 수 있다.

    ```
    export async function getAllPostIds() {

      const res = await fetch('..')
      const posts = await res.json()

      return posts.map(post => {
        return {
          params: {
            id: post.id
          }
        }
      })
    }
    ```

    <br />

- [Fallback](https://nextjs.org/docs/api-reference/data-fetching/get-static-paths#fallback-true "fallback 추가 정보")

  - `fallback`이 `false`라면, `getStaticPaths`에 의해 리턴되지 않은 모든 경로는 404 페이지로 이동한다.

  - `fallback`이 `true`라면, `getStaticProps`의 대응 방식은 다음과 같다.

    - `getStaticPaths`로부터 리턴된 경로는 빌드타임 때 HTML에 렌더링된다.

    - 빌드타임 때 생성되지 않은 경로는 404 페이지로 이동되지 않고, Next.js는 그 경로에 대한 첫 번째 요청에 `fallback` 페이지를 제공한다.

    - Next.js는 요청된 경로를 정적으로 생성하는데, 동일 경로에 대한 추후의 요청은 빌드타임 때 렌더링된 다른 페이지들처럼 생성되어 있던 페이지를 제공한다.

  - 만약 `fallback`이 `blocking`이라면, 새로운 경로는 `getStaticProps`로 서버 사이드 렌더링되고, 이후의 요청을 위해 캐시에 저장되며 경로 하나당 딱 한 번 발생한다.

  <br />

- Router Hook

  - URL에 데이터를 숨겨서 보낼 수 있다.

  - router의 push 메소드로 URL 마스킹도 가능하다.

    ```
    // Home.js

    export default function Home({ results }) {
      const router = useRouter();

      const onClick = (id, title) => {
        router.push(`/movies/${title}/${id}`)
      }
      // 1. 이 코드는 단순히 string으로 navigate하는 코드이고,

      // 2. 아래 코드는 object로 데이터를 추가해서 보내고, URL 마스킹까지 한 코드이다.
      const onClick = (id, title) => {
        router.push({
          pathname: `/movies/${id}`,
          query: {
            title,
          }
        },
        `/movies/${id}` // -> [as]를 사용해서
        )
      }
      // 이 방법을 사용하고 실제로 페이지를 이동해보면 /movies/1234로 이동된다.

      return
      <div>
        {results.map(movie => (
          <div onClick={() => onClick(movie.id, movie.title)}>
            // 1.
            <Link href={`/movies/${movie.title}/${movie.id}`}>

            // 2.
            <Link
              href={{
                pathname: `/movies/${movie.id}`,
                query: {
                  title: movie.original_title,
                },
              }}
              as={`/movies/${movie.id}`}
            >
              <a>{movie.title}</a>
            </Link>
          </div>
        ))}
      </div>
    }
    ```

    ```
    // 1. [...params].js

    import { useRouter } from "next/router";

    export default function Detail() {
      const router = useRouter();
      const [title, id] = router.query.params;
      return <div>
        <h4>{title}</h4>
      <div>
    }
    ```

    ```
    // 2. [id].js

    import { useRouter } from "next/router";

    export default function Detail() {
      const router = useRouter();
      return <div>
        <h4>{router.query.title || "Loading..." }</h4>
      <div>
    }
    ```

  - 하지만 위 방법을 사용해서 URL로 넘겨준 데이터를 사용할 때에는 문제가 생길 수 있다.

    - 이 페이지는 서버에서 프리렌더링되는데, 사용자가 홈페이지에서 상세 페이지로 이동하지 않는 이상 `router.query.params`와 `router.query.title`은 (배열로, 혹은) 존재하지 않기 때문에 에러가 발생한다.

  - 이 문제를 해결하기 위해서 다음과 같이 코드를 변경해서, CSR 방식을 이용할 수 있지만,

    ```
    // 1. [...params].js

      import { useRouter } from "next/router";

      export default function Detail() {
        const router = useRouter();
        const [title, id] = router.query.params || [];
        return <div>
          <h4>{title}</h4>
        <div>
      }
    ```

    - 소스 코드에서는 `movie.title`을 확인할 수 없으므로 SEO 측면에서 좋지 않을 수 있다.

  - 다른 방법은 `getServerSideProps`를 사용해서 페이지 렌더링 전에 데이터를 불러오는 것이다.

    ```
    // [...params].js
    import Seo from "../../components/Seo"

    export default function Detail({ params }) {
      const [title, id] = params || [];
      return <div>
        <Seo title={title} />
        <h4>{title}</h4>
      <div>
    }

    export function getServerSideProps({ params: { params } }) {
      return {
        props: {
          params,
        }
      }
    }
    ```
