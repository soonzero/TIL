# 불변성(immutablity)

자바스크립트에서 값\*이 가질 수 있는 타입\*\*은 원시 타입과 객체 타입으로 나뉜다.

\* 값: 메모리에 저장되는 데이터

\*\* 타입: 값이 메모리에 저장되거나 메모리에서 읽힐 때, 메모리 공간을 얼마나 확보하거나 조회할지 준비하기 위해 사용되는 개념

## 불변성이란?

불변성이란 말 그대로 변하지 않는 특성을 의미한다. 쉽게 말하면 데이터의 원본이 훼손되는 것을 막는 것이다.

자주 협업을 해야하는 개발자로서, 유지보수가 가능하고 가독성이 좋은 코드를 작성해야 할 의무가 있다.

만약 불변성을 지키지 않는다면 미래에 사용될 데이터가 어디서 어떻게 변하는지 흐름을 쫓기 어렵다.

불변성을 지켜 작성된 코드는 다른 개발자가 코드를 봤을 때도 의심 없이 코드를 읽는 그대로 흐름을 따라가면서 이해할 수 있게 해준다.

불변성에 대한 더욱 자세한 내용은 [이 블로그](https://evan-moon.github.io/2020/01/05/what-is-immutable/)를 참고하자.

## 원시 타입과 객체 타입

<table>
  <thead>
    <tr>
      <td>원시 타입</td>
      <td>객체 타입</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>문자, 숫자, 불리언, null, undefined, 심볼</td>
      <td>객체, 배열, 함수, 정규 표현식</td>
    </tr>
    <tr>
      <td>원자처럼 더 이상 분해될 수 없는 데이터</td>
      <td>여러 원시 타입을 비롯한 기타 정보의 조합</td>
    </tr>
  </tbody>
</table>

자바스크립트 엔진은 값이 원시 타입인지, 객체 타입인지에 따라 그 값이 담긴 변수가 메모리를 사용하는 방식이 다르다.

### 원시 타입

원시 타입은 값이 가볍기 때문에 원시 타입의 값을 담은 변수는 메모리에 그 값 자체를 담는다.

변수에 새로운 값을 재할당하는 경우, 새로운 메모리 공간을 확보함으로써 기존 데이터에 영향을 주지 않는다는 특징이 있다.

변수에 변수를 재할당하는 것을 **복사**라고 한다.

이 때 원본 변수에 담긴 값이 원시 타입인지, 객체 타입인지에 따라 원본 데이터의 훼손 여부가 결정된다.

```
let pr1 = 1;
let pr2 = p1;
// pr1 = 1 (1번 주소)
// pr2 = 1 (2번 주소)
// 값이 원시 타입이면 값 자체가 담기기 때문에 pr1과 pr2는 같은 값이 담겨있지만, 메모리 주소는 전혀 다르다.

console.log(pr1 === pr2); // true
// 같은 값이 담겨 있기 때문

pr2 = 100;
console.log(pr1, pr2, pr1 === pr2); // 1 100 false
```

변수 pr2에 pr1의 값을 할당했다가 100의 값을 재할당했지만, 변수 pr1에 저장되어 있던 값 1은 잘 보존되고 있다.

**이는 두 변수가 원시 타입을 갖고 있으며, 원시 타입은 복사할 때 새로운 주소로 바뀌기 때문이다.**

### 객체 타입

객체 타입은 보유하고 있는 데이터의 양이 많기 떄문에 원시 타입처럼 새로운 메모리 공간을 확보하기엔 많은 비용이 든다.

따라서 원시 타입처럼 값을 바로 저장하지 않고, 값이 저장된 메모리 위치를 저장함으로써 기존 값에 영향을 줄 수 있도록 만들어졌다.

```
let obj1 = { name: "one" };
let obj2 = obj1;
// obj1 = { name: "one" }
// obj2 = { name: "one" } (1번 주소)

console.log(obj1 === obj2); // true
// 값이 객체 타입이면 메모리 주소가 담기기 때문에 두 변수는 같음 메모리 주소를 갖고 있다.

obj2.name = "two";
console.log(obj1.name, obj2.name); // two two
```

obj1은 건드리지 않고, obj2의 name 프로퍼티만 변경했는데 obj1의 name 프로퍼티도 한 번에 변경되었다.

**객체 타입은 복사할 때 주소를 유지하기 때문이다.**

이러한 객체 타입의 특성은 **불변성**을 해친다.

앱의 규모가 커지면 원본이 언제 어디서 훼손되는지 알기 힘들어지기 때문에 의도하지 않은 상황이라면 난감해질 수 있다.

따라서 객체 타입의 값을 복사할 때에는 원본 주소와 관계 없는 새로운 값을 만들어야 한다.

### 객체 타입의 복사 방법 - 얕은 복사

1. `Object.assign()` 사용

```
let obj1 = { name: "one" };
let obj2 = Object.assign({}, obj1); // 첫 번째 인자인 빈 객체({})에 두 번째 인자인 obj1을 복사하여 할당한다.

console.log(obj1 === obj2); // false: 보유하고 있는 프로퍼티는 같지만 참조하는 메모리 주소가 전혀 다르다.

obj2.name = "two";
console.log(obj1.name, obj2.name); // one two
```

2. 스프레드 연산자(`...`) 사용

```
let obj1 = { name: "one" };
let obj3 = { ...obj1 }; // obj1의 모든 속성들을 복사하여 할당한다.

console.log(obj1 === obj3); // false: 보유하고 있는 프로퍼티는 같지만 참조하는 메모리 주소가 전혀 다르다.

obj3.name = "three";
console.log(obj1.name, obj3.name) // one three
```

위 방법들을 사용하면 원본 객체인 obj1의 프로퍼티를 훼손하지 않고 객체를 복사할 수 있다.

### 객체 타입의 재할당에 대한 불변성

단순히 재할당에 대한 불변성도 존재한다.

const 키워드로 변수를 선언하면서 값을 초기화하면 그 값은 끝까지 훼손되지 않고 보존된다.

```
const obj0 = { name: "zero" };
obj0.name = "not_zero";

console.log(obj0.name); // not_zero
```

알고 있던 const의 지식으로는 `obj0.name`은 변할 수 없으니 여전히 zero가 출력될 것 같지만,

const는 객체 내부의 프로퍼티들까지 지켜주지는 않는다.

이렇게 객체 타입 내부의 프로퍼티까지 불변성을 유지하려면 `Object.freeze()` 메소드를 사용해야 한다.

위 예시를 그대로 사용해보면 다음과 같다.

```
const obj0 = { name: "zero" };
Object.freeze(obj0); // obj0의 프로퍼티까지 불변성을 유지하겠다.
obj0.name = "not_zero";

console.log(obj0.name); // zero
```

하지만 이 방법도 한계가 있다. `Object.freeze()` 메소드는 최상위 프로퍼티에서만 불변성을 부여할 수 있기 때문이다.

```
const obj0 = {
  name: {
    firstName: "soon",
    lastName: "zero",
}}

Object.freeze(obj0); // obj0의 내부 프로퍼티까지 불변성을 유지하겠다.

obj0.name = "soonzero";
obj0.lastName = "one";
console.log(obj0);
// obj0 = {
//   name: {
//     firstName: "soon",
//     lastName: "one",
//   }
// }
```

위 예시처럼 최상위 프로퍼티에서만 불변성이 부여되고, 그 하위 프로퍼티들은 여전히 수정이 가능한 것을 알 수 있다.

얕은 복사의 문제점을 깊은 복사를 통해 해결할 수 있지만, 자바스크립트로 구현하기에는 조금 복잡하다.

이 때 사용할 수 있는 외부 라이브러리가 있는데 그것이 바로 lodash이다.
