# 모듈 번들러와 웹팩

하나의 웹 서비스는 수많은 리소스들의 집합체라고 할 수 있다.

리액트에서는 코드를 재사용하기 위해 컴포넌트를 모듈 형식으로 분리하는 모듈 단위의 개발 방식을 사용한다.

코드를 모듈 형식으로 분리한다면 개발자의 입장엥서는 코드의 반복도 줄이고, 유지보수에도 큰 이점을 챙길 수 있다.

<br />

하지만 사용자의 입장에서는 어떨까?

사용자가 웹 서비스에 접속하면 브라우저는 해당 페이지에서 필요한 리소스를 서버로 요청하게 된다.

모듈 형식으로 개발된 웹 서비스라면 굉장히 많은 모듈이 필요하므로 서버로 요청하는 횟수도 증가한다.

이처럼 네트워크 비용의 증가는 사용자의 서비스 이용에 걸리는 시간도 증가될 뿐더러,

네트워크 문제가 발생해 하나의 모듈이라도 놓치게 된다면 사용자 경험이 좋지 않을 수 있다.

<br />

## 모듈 번들러(Module Bundler)

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpeVFt%2FbtrDWToVDl5%2FzNqYRUNPn8kgO7kbUVDk20%2Fimg.png" alt="bundle your assets" />

<br />

왼쪽의 수많은 리소스들을 하나로 모아 통합해주는 도구를 모듈 번들러라고 하고, 대표적인 모듈 번들러로 웹팩(Webpack)이 있다.

모듈 번들러로 리소스들을 통합시켜주면 사용자의 브라우저가 서버로 요청하는 리소소의 개수가 줄어들어 네트워크 비용이 감소하고 서비스 품질이 향상된다.

그래서 React, Vue, Angular 등 모듈 단위의 개발 방식을 사용하는 라이브러리에서는 번들러의 사용이 필수적이다.

<br />

## 웹팩(Webpack)

웹팩은 ES5가 호환되는 브라우저를 지원하며 `import()` 및 `require.ensure()`을 위한 Promise를 요구하기 때문에,

구형 브라우저를 지원하기 위해서는 위 표현식들을 사용하기 전에 폴리필을 꼭 로드해줘야 한다.

<br />

### `mode`

- development

- production

- none

웹팩의 모드는 위 세 가지로 설정할 수 있고, production이 기본값으로 설정되어 있다.

각 모드에 따라 번들된 파일의 크기가 달라지는데 아래 순서로 파일이 커진다.

    production < development < none

개발 중에는 development를 사용하고, 배포 시에는 production을 사용한다.

```
// webpack.config.js

module.exports = {
  mode: "development",
};
```

<br />

### `entry`, `output`

#### `entry`

엔트리에는 번들링을 할 파일을 기입하면 된다.

예를 들어 리액트에서 모든 모듈의 root는 `./src/index.js`이기 때문에 아래와 같이 설정해주면 되고,

엔트리는 여러 개의 파일을 입력할 수 있기 때문에 의존성이 없는 다른 파일도 존재한다면 복수로 입력하면 된다.

```
// webpack.config.js

// 축약 문법
module.exports = {
  entry: ["./src/index.js", "./src/another_file.js"],
};

// 기본 문법
module.exports = {
  entry: {
    main: "./src/index.js",
  }
}
```

<br />

#### `output`

아웃풋은 번들된 파일을 내보낼 위치와 이름 등을 지정할 때 사용한다.

`output.path`와 `output.filename`을 설정해주면 해당 경로에 설정한 파일 이름으로 번들링되어 웹팩이 저장해준다.

```
const path = require("path");

module.exports = {
  entry: "./src/index.js",
  output: {
    path: path.resolve(__dirname, "dist"),
    filename: "bundle.js",
  },
};
```

<br />

### `Loaders`

웹팩은 기본 자바스크립트와 JSON 파일만 이해할 수 있기 때문에, CSS나 이미지 등 다른 유형의 파일을 번들링할 때에는 로더를 사용해야 한다.

로더는 `module.rules` 배열에 객체 형식으로 개별로 입력해준다.

여러 종류의 로더 중 대표적인 Babel과 CSS 관련 파일을 처리해주는 `style-loader/css-loader`를 아래 방법으로 설정할 수 있다.

<br />

#### `Babel Loader`

```
// 개발 모드에서 사용할 수 있도록 설치한다.

npm i -D babel-loader @babel/core @babel/preset-env
```

```
module: {
  rules: [
    {
      test: /\.js/,
      exclude: /node_modules/,
      use: {
        loader: "babel-loader",
        options: {
          presets: ["@babel/preset-env"] // 배열 요소 추가로 여러 프리셋을 설정할 수 있다.
        },
      },
    },
  ]
};
```

<br />

#### `style-loader`/`css-loader`

```
// 개발 모드에서 사용할 수 있도록 설치한다.

npm i -D style-loader css-loader
```

```
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/i,
        user: ["style-loader", "css-loader"],
      }
    ]
  }
};
```

<br />

### `Plugins`

플러그인은 모듈을 변환하는 데에 사용하며, 번들 작업의 최적화, 리소스 관리, 환경 변수 주입 등 많은 작업을 수행할 수 있다.

플러그인을 사용하기 위해서 `require()`를 통해 플러그인을 불러오고 plugins 배열에 new 연산자로 인스턴스를 생성해 사용한다.

플러그인의 종류도 여러 가지가 있으며, 아래는 기본적으로 사용되는 `HtmlWebpackPlugin`의 설정 방법이다.

이 플러그인은 번들된 모듈 파일을 자동으로 삽입하여 배포용 HTML 파일을 생성해준다.

<br />

#### `HtmlWebpackPlugin`

```
// 개발 모드에서 사용할 수 있도록 설치한다.

npm i -D html-webpack-plugin
```

```
const HtmlWebpackPlugin = require("html-webpack-plugin");

module.exports = {
  plugins: [
    new HtmlWebpackPlugin(
      {
        template: "./public/index.html", // 템플릿 설정
        minify: true, // 압축 설정
      }
    )
  ]
}
```

#### `CleanWebpackPlugin`

```
// 개발 모드에서 사용할 수 있도록 설치한다.

npm i -D clean-webpack-plugin
```

번들 시 이전 번들된 결과들을 지워주는 플러그인으로, 리액트에서는 기본적으로 사용되고 있다.

<br />

## 전체 코드

```
// webpack.config.js

const path = require("path");
const HtmlWebpackPlugin = require("html-webpack-plugin")
const { CleanWebpackPlugin } = require("clean-webpack-plugin")

module.exports = {
  name: "webpack-config",
  mode: "developemtn",
  devtool: "eval",
  entry: {
    app: "./src/index.js",
  },
  module: {
    rules: [
      {
        test: /\.js/,
        exclude: /node_modules/,
        use: {
          loader: "babel-loader",
          options: {
            presets: ["@babel/preset-env"]
          },
        },
      },
      {
        test: /\.css$/i,
        use: ["style-loader", "css-loader"],
      },
    ]
  },
  plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin(
      {
        template: "./public/index.html",
        minify: true,
      }
    )
  ],
  output: {
    path: path.resolve(__dirname, "dist"),
    filename: "app.js",
  }
}
```
