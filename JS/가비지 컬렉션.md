# 가비지 컬렉션(Garbage Collection)

자바스크립트는 가비지 컬렉터가 자동으로 메모리를 관리해주는데, 쓸모 없어진 객체가 차지하는 메모리를 자동으로 해제하는 것을 의미한다.

#### 장점

- 메모리 관리를 완벽하게 할 필요가 없다.

#### 단점

- 언제 가비지 컬렉션이 진행될 지 예측하기 어렵다.

  - 객체가 쓸모 없어지는 시점에 정확히 메모리가 해제되는 것이 아니기 때문에 최적의 메모리 관리가 이루어지지는 않는다.

- 가비지 컬렉터가 동작하는 데에 시간이 소요된다.

  - 어떤 객체가 쓸모 없는지 판단하기 위한 시간이 필요하다.

## 자바스크립트의 변수와 메모리

### Primitive Type

- 자바스크립트 원시 타입은 숫자, 문자열, 불리언, null, undefined, 심볼 이렇게 6개가 있다.

- 원시 타입 데이터는 불변하는 데이터로, 메모리를 한 번 할당받으면 값이 변경되지 않는다.

```
let num; // undefined
num = 80;
num = 100;
```

<img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdd6b8c89-4333-4bd2-b164-49a172e88cb5%2FUntitled.png?table=block&id=27f3bcb9-c89c-4ce7-a581-f4bcf904884e&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="primitive type" />

- 자바스크립트에서는 값을 재할당하면 새로운 메모리 공간을 할당받아 값을 넣고, 변수가 가리키는 메모리 주소를 변경한다.

- 이전 값은 더 이상 사용되지 않기 때문에 가비지 컬렉션의 대상이 된다.

### Object Type

- 원시 타입을 제외한 모든 것이 객체 타입으로, 객체, 배열, 함수 등이 있다.

- 객체 타입을 변수에 할당하면, 변수에는 실제 객체가 저장된 힙 메모리 주소가 저장된다.

```
const person = {
  name: "Lee";
};
```

- 객체 타입을 담은 변수를 다른 변수에 할당하면, 메모리 주소를 공유하기 떄문에 같은 객체를 가리킨다.

```
const p1 = person;

p1 === person // true
```

- 객체를 복사해서 새로운 변수에 할당하면, 객체의 구성은 같을 수 있어도 메모리 주소가 다르기 때문에 서로 다른 객체이다.

```
const p2 = { ... person };

p2 === person // false
```

- 즉, 자바스크립트 객체에 접근하는 방법은 메모리 주소를 통하는 것으로, 일종의 포인터 역할을 한다.

- 객체를 가리키는 포인터가 하나도 없으면 객체를 사용할 방법이 없기 때문에 가비지 컬렉션의 대상이 되는 것이다.

**중요한 점은 "메모리가 더 이상 필요하지 않을 때 해제해야 한다"는 것이다.**

## 가비지 컬렉션 알고리즘

1. Reference-Counting

참조 개수를 카운트하여 참조가 하나도 없으면 가비지로 판단하는 방법

```
let x = {
  a: {
    b: 2,
  },
}
```

- 할당된 모든 메모리가 참조당하고 있는 상태로, 가비지가 없는 상태라고 할 수 있다.

- 애초에 전역 변수는 가비지 컬렉션의 대상이 아니므로 x에 대한 카운팅은 제외한다.

```
let y = x;
x = 1
```

- 변수 y에 변수 x를 대입해서 객체의 메모리 주소를 연결하고, 변수 x에는 1을 할당해서 객체와의 연결을 끊는다.

- 현재 모든 메모리의 참조가 아직 가비지 컬렉션의 대상이 아니다.

```
let z = y.a.b;
y = "bumsu"
```

- 변수 z에 y.a.b를 대입하면 객체 b의 메모리 주소가 연결되고, 변수 y에 문자열을 할당해서 객체 a와의 연결을 끊는다.

- 객체 a를 참조하는 변수가 하나도 없기 때문에 가비지로 인식하고 메모리 공간을 해제한다.

```
z = null;
```

- 변수 z에 null을 대입해서 객체 b와의 연결을 끊으면, 객체 b는 가비지로 인식되고 메모리 공간이 해제되며 숫자 2도 메모리 공간이 해제된다.

#### 순환 참조

- 두 개의 객체가 서로 참조하면 순환 구조가 생성되어 가비지로 인식되지 않는다.

```
function f() {
  const x = {};
  const y = {};
  // x, y를 가리키는 참조가 없는 상태로 선언

  // 객체에 속성 a를 추가하고, 서로를 참조
  x.a = y
  y.a = x
};

f();
```

- 클로저와 같이 함수가 종료된 후에도 변수에 접근할 수 있는 형태가 아니다.

- 함수 f의 컨텍스트가 끝나는 순간에 x와 y의 메모리를 해제시켜줘야 하는데, x.a, y.a에 의한 참조 카운팅이 되기 때문에 가비지로 분류가 불가능하다.

```
var div;
window.onload = function() {
  div = document.getElementById("myDivElement");
  div.circularReference = div;
  div.lotsOfData = new Array(10000).join("*");
}
```

- 실제로 IE6, 7버전에서는 Reference-Counting 방식으로 가비지 컬렉션을 진행했고, 메모리 누수가 발생할 수 있었다.

  - 따라서 개발자가 순환 참조가 발생되지 않도록 신경쓰면서 개발해야 한다는 불편함이 존재했다.

## Mark-and-Sweep

이 알고리즘에서는 가비지를 **닿을 수 없는 메모리**로 정의한다.

roots라는 전역 변수의 집합부터 시작해 roots가 참조하는 객체 -> 그 자식들이 참조하는 객체 -> ...

이런 식으로 접근 가능한 객체들을 선별하고, 접근이 불가능한 객체들을 가비지로 판단하는 방법이다.

실행 컨텍스트가 소멸되는 순간, 접근하기 불가능한 객체가 되기 때문에 순환 참조는 발생하지 않는다.

2012년부터 모든 최신 브라우저들이 Mark-and-Sweep 알고리즘으로 가비지 컬렉션을 진행한다.

### Mark-and-Sweep의 3가지 상태

모든 객체를 3가지 상태로 분류하여 가비지 여부를 판단하는데,

1. White: 아직 가비지 컬렉터가 탐색하지 못한 상태

2. Gray: 가비지 컬렉터가 탐색했으나, 해당 객체가 참조하는 객체들은 탐색하지 못한 상태

3. Black: 가비지 컬렉터가 탐색했고, 해당 객체가 참조하는 객체들도 모두 탐색을 완료한 상태

### Mark-and-Sweep의 구동 과정

```
let x = {
  a: {
    b: 2,
  },
}

let y = x;
x = 1;

let z = y.a.b;
y = "bumsu";

z = null;
```

- 마지막 줄이 실행될 때까지 가비지 컬렉션이 수행되지 않았다고 가정하면, 다음과 같은 메모리 구조가 된다.

1. Marking

1. roots를 모두 회색으로 마킹하고, Deque에 push한다.

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F915bcc5b-ac66-47c4-b9d2-6c4d922a2b4c%2FUntitled.png?table=block&id=b097bfe5-c253-4791-9891-a316d392262e&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-1"/>

2. Deque에서 shift하여 객체를 꺼내고, 검은색으로 마킹한다.

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8fb47e0a-67af-408d-8b15-ba2699b9fe2b%2FUntitled.png?table=block&id=5dfd5725-cd6a-449f-92f3-d9e9b3a3188c&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-2" />

3. 검은색으로 마킹된 객체가 참조하는 객체들을 회색으로 마킹하고, unshift한다.

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fecea3cde-49bc-49fd-89fc-6199069075df%2FUntitled.png?table=block&id=b4fd2f9f-2ee5-4dbc-b5b9-80806cf0aebb&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-3" />

4. Deque가 완전히 빌 때까지 2, 3번을 반복한다.

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff8a17b53-eeb7-4066-8804-7aa969171b98%2FUntitled.png?table=block&id=9a631f74-ceb6-4e60-bd25-82a23ed84638&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-4-1" />

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F64e10bc5-ffda-45f5-9ced-2ee2af8fccd2%2FUntitled.png?table=block&id=639483a3-cee3-4408-b5ed-dbe3a79ecfe3&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-4-2" />

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd5877c11-cfc1-4945-83dc-1be0b44dc0b9%2FUntitled.png?table=block&id=8a23cdd9-545c-4ff8-b702-7304170c01f3&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-4-3" />

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1a250eb8-1dfe-4c60-8c04-15818968f292%2FUntitled.png?table=block&id=27ca4f28-265a-4baa-90dd-2db1220c6872&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-4-4" />

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd9ed91d4-fbe0-4390-950b-3b6647f24223%2FUntitled.png?table=block&id=0fd22001-4801-45b2-8157-519ee91110cc&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-4-5" />

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd6eb8b30-20a3-4a31-ad58-9c80fa828cfd%2FUntitled.png?table=block&id=05a2af74-0015-4b93-92f1-13ce3275b4b5&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-4-6" />

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F90861147-bd1b-40f3-a28e-fb322372485a%2FUntitled.png?table=block&id=364d7061-4114-43af-a87c-3155c73da5e0&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-4-7" />

5. 최종적으로는 검은색과 흰색으로 분류되며, Deque는 완전히 빈다.

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3b92aa81-53ac-4754-9cab-7f238f9ec7fa%2FUntitled.png?table=block&id=0a8f085f-549d-4f92-9a01-faccb3368229&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-5" />

2. Sweep

흰색으로 마킹된 객체들을 가비지로 인식하고 메모리를 해제한다.

3. Compact

메모리의 파편화가 심해지지 않도록 메모리를 재배치하여 메모리를 확보한다.

<img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbffa9b75-dd7d-4102-8c37-e1fb7276778d%2FUntitled.png?table=block&id=2b1278af-eb15-4642-8013-518092dafa75&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-compact" />

#### 전체 동작 과정

<img src="https://blog.kakaocdn.net/dn/bEkhNs/btqEoAhx6q0/x57jk6pga9KpkllY3ysHyk/img.gif" alt="mark-and-sweep-simple" />
