# 가비지 컬렉션(Garbage Collection)

자바스크립트는 가비지 컬렉터가 자동으로 메모리를 관리해주는데, 쓸모 없어진 객체가 차지하는 메모리를 자동으로 해제하는 것을 의미한다.

#### 장점

- 메모리 관리를 완벽하게 할 필요가 없다.

#### 단점

- 언제 가비지 컬렉션이 진행될 지 예측하기 어렵다.

  - 객체가 쓸모 없어지는 시점에 정확히 메모리가 해제되는 것이 아니기 때문에 최적의 메모리 관리가 이루어지지는 않는다.

- 가비지 컬렉터가 동작하는 데에 시간이 소요된다.

  - 어떤 객체가 쓸모 없는지 판단하기 위한 시간이 필요하다.

## 자바스크립트의 변수와 메모리

### Primitive Type

- 자바스크립트 원시 타입은 숫자, 문자열, 불리언, null, undefined, 심볼 이렇게 6개가 있다.

- 원시 타입 데이터는 불변하는 데이터로, 메모리를 한 번 할당받으면 값이 변경되지 않는다.

```
let num; // undefined
num = 80;
num = 100;
```

<img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdd6b8c89-4333-4bd2-b164-49a172e88cb5%2FUntitled.png?table=block&id=27f3bcb9-c89c-4ce7-a581-f4bcf904884e&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="primitive type" />

- 자바스크립트에서는 값을 재할당하면 새로운 메모리 공간을 할당받아 값을 넣고, 변수가 가리키는 메모리 주소를 변경한다.

- 이전 값은 더 이상 사용되지 않기 때문에 가비지 컬렉션의 대상이 된다.

### Object Type

- 원시 타입을 제외한 모든 것이 객체 타입으로, 객체, 배열, 함수 등이 있다.

- 객체 타입을 변수에 할당하면, 변수에는 실제 객체가 저장된 힙 메모리 주소가 저장된다.

```
const person = {
  name: "Lee";
};
```

- 객체 타입을 담은 변수를 다른 변수에 할당하면, 메모리 주소를 공유하기 떄문에 같은 객체를 가리킨다.

```
const p1 = person;

p1 === person // true
```

- 객체를 복사해서 새로운 변수에 할당하면, 객체의 구성은 같을 수 있어도 메모리 주소가 다르기 때문에 서로 다른 객체이다.

```
const p2 = { ... person };

p2 === person // false
```

- 즉, 자바스크립트 객체에 접근하는 방법은 메모리 주소를 통하는 것으로, 일종의 포인터 역할을 한다.

- 객체를 가리키는 포인터가 하나도 없으면 객체를 사용할 방법이 없기 때문에 가비지 컬렉션의 대상이 되는 것이다.

**중요한 점은 "메모리가 더 이상 필요하지 않을 때 해제해야 한다"는 것이다.**

## 가비지 컬렉션 알고리즘

1. Reference-Counting

참조 개수를 카운트하여 참조가 하나도 없으면 가비지로 판단하는 방법

```
let x = {
  a: {
    b: 2,
  },
}
```

- 할당된 모든 메모리가 참조당하고 있는 상태로, 가비지가 없는 상태라고 할 수 있다.

- 애초에 전역 변수는 가비지 컬렉션의 대상이 아니므로 x에 대한 카운팅은 제외한다.

```
let y = x;
x = 1
```

- 변수 y에 변수 x를 대입해서 객체의 메모리 주소를 연결하고, 변수 x에는 1을 할당해서 객체와의 연결을 끊는다.

- 현재 모든 메모리의 참조가 아직 가비지 컬렉션의 대상이 아니다.

```
let z = y.a.b;
y = "bumsu"
```

- 변수 z에 y.a.b를 대입하면 객체 b의 메모리 주소가 연결되고, 변수 y에 문자열을 할당해서 객체 a와의 연결을 끊는다.

- 객체 a를 참조하는 변수가 하나도 없기 때문에 가비지로 인식하고 메모리 공간을 해제한다.

```
z = null;
```

- 변수 z에 null을 대입해서 객체 b와의 연결을 끊으면, 객체 b는 가비지로 인식되고 메모리 공간이 해제되며 숫자 2도 메모리 공간이 해제된다.

#### 순환 참조

- 두 개의 객체가 서로 참조하면 순환 구조가 생성되어 가비지로 인식되지 않는다.

```
function f() {
  const x = {};
  const y = {};
  // x, y를 가리키는 참조가 없는 상태로 선언

  // 객체에 속성 a를 추가하고, 서로를 참조
  x.a = y
  y.a = x
};

f();
```

- 클로저와 같이 함수가 종료된 후에도 변수에 접근할 수 있는 형태가 아니다.

- 함수 f의 컨텍스트가 끝나는 순간에 x와 y의 메모리를 해제시켜줘야 하는데, x.a, y.a에 의한 참조 카운팅이 되기 때문에 가비지로 분류가 불가능하다.

```
var div;
window.onload = function() {
  div = document.getElementById("myDivElement");
  div.circularReference = div;
  div.lotsOfData = new Array(10000).join("*");
}
```

- 실제로 IE6, 7버전에서는 Reference-Counting 방식으로 가비지 컬렉션을 진행했고, 메모리 누수가 발생할 수 있었다.

  - 따라서 개발자가 순환 참조가 발생되지 않도록 신경쓰면서 개발해야 한다는 불편함이 존재했다.

## Mark-and-Sweep

이 알고리즘에서는 도달 가능성(reachability)이라는 개념을 사용해 가비지를 판단하고, 메모리 관리를 수행한다.

roots라는 전역 변수의 집합부터 시작해 roots가 참조하는 객체 -> 그 자식들이 참조하는 객체 -> ...

이런 식으로 접근 가능한 객체들을 선별하고, 접근이 불가능한 객체들을 가비지로 판단하는 방법이다.

실행 컨텍스트가 소멸되는 순간, 접근하기 불가능한 객체가 되기 때문에 순환 참조는 발생하지 않는다.

2012년부터 모든 최신 브라우저들이 Mark-and-Sweep 알고리즘으로 가비지 컬렉션을 진행한다.

### Mark-and-Sweep의 3가지 상태

모든 객체를 3가지 상태로 분류하여 가비지 여부를 판단하는데,

1. White: 아직 가비지 컬렉터가 탐색하지 못한 상태

2. Gray: 가비지 컬렉터가 탐색했으나, 해당 객체가 참조하는 객체들은 탐색하지 못한 상태

3. Black: 가비지 컬렉터가 탐색했고, 해당 객체가 참조하는 객체들도 모두 탐색을 완료한 상태

### Mark-and-Sweep의 구동 과정

```
let x = {
  a: {
    b: 2,
  },
}

let y = x;
x = 1;

let z = y.a.b;
y = "bumsu";

z = null;
```

- 마지막 줄이 실행될 때까지 가비지 컬렉션이 수행되지 않았다고 가정하면, 다음과 같은 메모리 구조가 된다.

1. Marking

1. roots를 모두 회색으로 마킹하고, Deque에 push한다.

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F915bcc5b-ac66-47c4-b9d2-6c4d922a2b4c%2FUntitled.png?table=block&id=b097bfe5-c253-4791-9891-a316d392262e&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-1"/>

2. Deque에서 shift하여 객체를 꺼내고, 검은색으로 마킹한다.

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8fb47e0a-67af-408d-8b15-ba2699b9fe2b%2FUntitled.png?table=block&id=5dfd5725-cd6a-449f-92f3-d9e9b3a3188c&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-2" />

3. 검은색으로 마킹된 객체가 참조하는 객체들을 회색으로 마킹하고, unshift한다.

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fecea3cde-49bc-49fd-89fc-6199069075df%2FUntitled.png?table=block&id=b4fd2f9f-2ee5-4dbc-b5b9-80806cf0aebb&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-3" />

4. Deque가 완전히 빌 때까지 2, 3번을 반복한다.

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff8a17b53-eeb7-4066-8804-7aa969171b98%2FUntitled.png?table=block&id=9a631f74-ceb6-4e60-bd25-82a23ed84638&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-4-1" />

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F64e10bc5-ffda-45f5-9ced-2ee2af8fccd2%2FUntitled.png?table=block&id=639483a3-cee3-4408-b5ed-dbe3a79ecfe3&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-4-2" />

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd5877c11-cfc1-4945-83dc-1be0b44dc0b9%2FUntitled.png?table=block&id=8a23cdd9-545c-4ff8-b702-7304170c01f3&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-4-3" />

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1a250eb8-1dfe-4c60-8c04-15818968f292%2FUntitled.png?table=block&id=27ca4f28-265a-4baa-90dd-2db1220c6872&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-4-4" />

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd9ed91d4-fbe0-4390-950b-3b6647f24223%2FUntitled.png?table=block&id=0fd22001-4801-45b2-8157-519ee91110cc&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-4-5" />

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd6eb8b30-20a3-4a31-ad58-9c80fa828cfd%2FUntitled.png?table=block&id=05a2af74-0015-4b93-92f1-13ce3275b4b5&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-4-6" />

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F90861147-bd1b-40f3-a28e-fb322372485a%2FUntitled.png?table=block&id=364d7061-4114-43af-a87c-3155c73da5e0&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-4-7" />

5. 최종적으로는 검은색과 흰색으로 분류되며, Deque는 완전히 빈다.

  <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3b92aa81-53ac-4754-9cab-7f238f9ec7fa%2FUntitled.png?table=block&id=0a8f085f-549d-4f92-9a01-faccb3368229&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-5" />

2. Sweep

흰색으로 마킹된 객체들을 가비지로 인식하고 메모리를 해제한다.

3. Compact

메모리의 파편화가 심해지지 않도록 메모리를 재배치하여 메모리를 확보한다.

<img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbffa9b75-dd7d-4102-8c37-e1fb7276778d%2FUntitled.png?table=block&id=2b1278af-eb15-4642-8013-518092dafa75&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="mark-and-sweep-compact" />

#### 전체 동작 과정

<img src="https://blog.kakaocdn.net/dn/bEkhNs/btqEoAhx6q0/x57jk6pga9KpkllY3ysHyk/img.gif" alt="mark-and-sweep-simple" />

## 메모리 관점에서의 가비지 컬렉션

자바스크립트 가비지 컬렉션이 실행되는 시점은 개발자가 특정할 수 없다.

하지만 가비지 컬렉션은 STW(Stop the World)가 발생해 전체 프로그램이 멈추는 시간이 발생하고, 메모리 탐색을 하는 무거운 작업이기 때문에

언제 가비지 컬렉션이 실행되는지 개념적으로라도 알고 있으면 좋다.

자바스크립트에서는 가비지 컬렉션이 메모리가 일정 수준 이상으로 사용되면 실행되는데, 메모리 관점에서의 동작 과정을 살펴보고 언제 실행되는지 알아보자.

### 1. V8 엔진 메모리 구조

<img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3cb1a343-b0ac-44c7-9c96-6facaccca7cd%2FUntitled.png?table=block&id=e951a780-4557-4689-881f-0853eae7ce7d&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="v8-engine-memory-structure" />

- V8 엔진에서 Heap 메모리는 객체와 동적 데이터가 저장되는 공간이면서 가비지 컬렉션이 발생하는 곳이다.

- 그 중에서도 New space와 Old space에서 가비지 컬렉션이 일어난다.

  - New space(Young Generation)

    - 새로 만들어진 객체가 저장되는 공간이다.

    - 아주 작은 크기가 할당되어 있고, 2개의 Semi space(To-space, From-space)로 이루어져 있다.

    - Scavenger라는 가비지 컬렉터가 관리하는 영역이며, Minor GC라고도 한다.

  - Old space(Old Generation)

    - New space에서 살아남은 객체들이 저장되는 공간으로, Minor GC에서 2번 이상 가비지 컬렉션을 실행했음에도 메모리 해제가 되지 않은 객체들이 저장된다.

    - **포인터**만 모아놓은 Old pointer spcae, **데이터**만 모아놓은 Old data space로 나뉜다.

    - Major GC가 메모리를 관리한다.

### 2. 포인터와 데이터 분기

가비지 컬렉션 알고리즘을 구현하기 위해서는 참조 관계를 파악할 수 있어야 하고, 포인터와 데이터를 구분할 수 있어야 한다.

따라서, 자바스크립트도 메모리상에서 포인터와 데이터를 구분하는 방법을 채택했는데 그 방법이 바로 **Tagged Pointers** 방법이다.

<img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3db43f41-03af-46db-a094-b443bf56a2dd%2FUntitled.png?table=block&id=590f1f49-fb65-40fd-890f-20b211aa65d4&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="tagged-pointers" />

데이터가 할당된 메모리 끝에 포인터인지 데이터인지 구분할 수 있는 비트 값을 저장한다.

- 0: 데이터

- 1: 포인터

약간의 메모리 오버헤드가 생기지만, 비교적 효율적으로 구현이 가능하다고 한다.

### 3. Minor GC 동작 과정

1.  새로운 객체로 인해 New space 공간이 초과되는 상황

    <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F35570550-5a6d-42ad-be8f-cc5ab9339359%2FUntitled.png?table=block&id=e0378faa-b058-407e-975f-21298db652f3&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="minor-gc-1" />

    - New space는 To-space와 From-space로 나뉘어져 있는데, 객체는 To-space에만 저장한다.

    - 현재 새로운 객체가 들어와야 하는데 To-space의 메모리 공간이 부족한 상황이다.

2.  To-space와 From-space의 역할 변경 및 객체 이동

    <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa71baf25-0a02-4088-8b7a-29b25d165ad0%2FUntitled.png?table=block&id=0ba27261-b107-45fc-89d5-2c32fbaa9289&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="minor-gc-2" />

    - From-space는 평소에 메모리가 비어있고, To-space의 메모리가 가득차게 되면, 두 공간의 역할이 바뀌게 된다.

    - 역할을 바꾸면서 원래 있던 객체들 중 참조를 당하고 있는 객체들만 다시 To-space로 이동되고 참조가 끊어진 객체들은 제거된다. (가비지 컬렉션 발생)

3.  새로운 객체는 메모리가 확보된 To-space에 추가된다.

    <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb79a21b0-2cc2-4864-8111-63efe919db61%2FUntitled.png?table=block&id=5fefbfcf-3141-4250-8a31-8bc2712737a6&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="minor-gc-3" />

4.  다시 To-space의 메모리가 초과되면 2번 이상 살아남은 객체는 Old space로 이동된다.

    <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F1d4c96cf-e7d2-4c70-83d9-6a75b7af06ed%2FUntitled.png?table=block&id=952e709a-f153-4d14-bb0f-97469a7b553d&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="minor-gc-4-1" />

    <br />

    - 1, 5번 객체는 이번 가비지 컬렉션에서 살아남았기 때문에(두 번째) Old space로 이동되며, 나머지 과정은 동일하다.

    <br />

    <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2ea1f9cb-a120-4a9f-93e7-e47d107839fa%2FUntitled.png?table=block&id=c7299c7f-8845-4970-b092-ba8b02d34096&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="minor-gc-4-2" />

5.  최종 결과

    <img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb5d54ca2-9e05-4d85-a83b-4e29b26ad725%2FUntitled.png?table=block&id=7c320113-30fd-4e44-9800-8538200ad460&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="minor-gc-5" />

    - To-space, From-space 2개의 메모리 공간의 역할을 바꿔가며 가비지 컬렉션을 실행하는 방법을 Scavenger(스캐벤저)라고 한다.

    - New space 메모리 공간이 아주 작게 할당되어 있기 때문에, 자주 메모리 공간이 가득차는 만큼 가비지 컬렉션도 자주 일어난다.

### 4. Write Barriers

Minor GC도 Mark-and-Sweep 알고리즘처럼, 루트에서 접근 불가능한 객체를 가비지로 판단한다.

그렇다면 New space 안에 있는 객체를 대상으로 가비지 컬렉션을 실행하더라도, 전체 Heap 메모리를 다 검사해야 할 가능성이 있다.

Minor GC는 자주 실행되기 때문에 매 실행마다 전체 Heap 메모리를 검사하는 것은 아주 큰 오버헤드다.

<img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F53420146-8b28-4776-942a-c8d62b5c1d9d%2FUntitled.png?table=block&id=4446899b-e782-4951-91e5-80b12b787113&spaceId=22b87c87-37c3-4e85-89cc-55a5980978e4&width=2000&userId=88006f41-c684-4a15-9c80-7e549f079723&cache=v2" alt="write-barriers" />

그렇다고 Old space를 고려하지 않고 가비지 컬렉션을 실행하면 포인터만 살아있는 Dangling Pointer가 발생할 수 있다.

그래서 V8 엔진에서는 Write Barriers라는 것을 만들어서 전체 Heap 메모리를 다 검사하는 것을 방지한다.

- Old space에 있는 객체가 New space에 있는 객체를 참조할 때, Stored buffer라는 공간에 참조한 New space의 객체의 위치를 저장한다.

- 그러면 Minor GC는 New space와 Stored buffer만 검사해도 객체들의 참조 여부를 알 수 있다.

### 5. Major GC 동작 과정

Major GC는 Mark-and-Sweep 알고리즘에서 설명한 것처럼 Marking-Sweep-Compact 과정으로 동작한다.

- Old space가 충분하지 않을 때 Major GC가 가비지 컬렉션을 실행한다.

- Minor GC, Major GC 모두 STW를 발생시켜 가비지 컬렉션 이외의 모든 동작이 멈춘다.

  - Minor GC는 속도가 굉장히 빨라 성능에 영향이 적다.

  - 하지만 Major GC는 메모리 공간이 커서 속도가 느리기 때문에 [최적화 기법](https://tech.ssut.me/concurrent-marking-in-v8/)을 사용할 수 있다.

    - 이 방법을 사용하면 마킹 시간을 최대 70%까지 줄일 수 있다고 한다.

#### [더 쉬운 설명](https://ko.javascript.info/garbage-collection)
